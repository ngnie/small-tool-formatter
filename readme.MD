# Intro
The below is a description of the choices I made and why for this task - but also thoughts in general.

Upon reading the task description, I took note of these two statements:

* The application must be written in a way that makes it possible to implement remaining algorithms without any considerable changes to existing code.
* It is allowed to use junit dependency for tests.

The above statements are like the "alpha" and the "omega", in my mind. Not practicing these principles lead to not
*Clean Code* and at the end of the day, technical debt.

So with the above in mind - code that can be unit tested, reused and extended - but also with Spring-boot in mind -
I have used the *Port Adapter* pattern for the task.

Yes, it is completely over-kill for the task being, but it illustrates the point.

# Port adapter
Also called the *Hexagon* pattern. I guess the term is borrowed from DDD i.e. Domain Driven Design, and it was coined around 2008-2011.

I was introduced to this pattern by a tech lead person. In the beginning, I didn't like it at all.

Some of my thoughts were:

* Oh well, I know perfectly well how to decouple.
* I know how to use an interface. What have we? Strategy, visitor, delegator etc.
* And yes, I know SOLID, principles, patterns and best practice.
* I know how to do unit test.
* It is waste of time with all these bloated adapters i.e. maven modules. It is confusing.
* I can perfectly well make a nice project structure - without modules.
* .. etc. etc.

The fact is that I use it now. I recommend this pattern in every larger Spring-boot project - with many developers.
Why? I would like to explain the pattern.

It consists of these elements (maven modules):

* Port (interfaces)
* Adapters (raw implementation)
* Domain (model i.e. POJO's and interfaces)
* Core (SpringBoot application startup)
* Config (Beans, properties etc.)
* Usecase (the business logic)

## Note
The pattern is called *Port and Adapter*, but actually the "port part" are the interfaces used which are located in
the domain module. In the following the *Port* is part of the *Domain*.

## Adapters
An *Adapter* is an implementation of some resource using raw types and methods from a particular library.

### Implementation
Implementations could be:

* SQL client doing CRUD operations.
* Apache Kafka client (publishing messages) or listener.
* REST client or endpoint.

The resource uses raw types for that implementation in question.

Example types are:

* DTO's generated by OpenAPI (openapi-generator-maven-plugin).
* Hibernate entities.

The adapter must implement a (port) interface.

### Dependencies
The adapter only has two Maven dependencies:

* the library used for that particular adapter e.g. Apache Kafka.
* the domain model.

Besides the above, the adapter is oblivious to all other modules in the project.
Also, adapters do not know about other adapters or use (inject) other adapters.

### Calling
The adapter can be:

* called by the initiator e.g. like a *client*.
* or make a call-back to the initiator e.g. like a *listener*.

Regardless, the type of call, a port interface must be used.
Parameters used in constructors and methods are domain type (or native types).

### Mapping
Mappers are located in the adapter. They're able to map between domain types and raw adapter types.
Raw adapter types does *not* escape the adapter.

## Domain
The domain consists of the *Types* and *Ports* used in the project.

### Types
This is basically POJO's without any annotations besides (maybe) Lombok.

*Important:* the use-case (business logic) only uses domain types (not raw 3rd part library types and methods).

### Port
Here the port interfaces reside each implemented by some adapter.

*Important:* the use-case (business logic) only uses port interfaces (not a concrete implementation of an adapter).

## Use-case
The use-case is the business logic. From a dependency point of view, it only knows the domain types and ports, not the
concrete adapter implementation. It is literately impossible to instantiate a concrete type of some adapter and use it
in the use case. And vice versa, from a dependency point of view, the adapters do not know anything about
the business logic i.e. the use-case. They are decoupled through the port interface.

## Config
The *Config* module configures the dependency management i.e. bean instantiation and injection. It includes most maven dependencies.

## Main
The *Main* module is responsible for config instantiation and then starting the application. 

## Conclusion
The result of using this pattern:
* decoupled - the use-case and adapters are completely decoupled. It is literately impossible to instantiate a concrete
  adapter implementation, thus it is not possible to have raw 3rd part types and library methods mixed with business logic.
  All in all, there is a good chance for *Clean Code*. 
* unit test (use-case) - because of the decoupling, the use-case unit test becomes very simple and clean, since it only
  focuses on business logic and domain types (includes port interfaces). Mocking and stubbing domain types and interfaces
  are very simple. And SpringBootTest is not used in this test.
* unit test (adapter) - this unit test is testing the concrete adapter implementation and which is tight coupled to 3rd part
  library dependencies. And that is fine. Also test framework dependencies can be used in the adapter e.g. H2. But again,
  neither the 3rd part library raw types or methods - nor H2 is mixed with the use-case. 
* overview - it is easy to overview the project. Developers know where to look.
* template - a standard project template can be made with most common modules and adapters.
* standard - it (maybe) makes it easier to communicate and keep the project *clean* (what ever that term is defined as).

# Questions

## 0d0a
It is not seen in the output example in the PDF, but this can be seen when looking in a hex editor:

    0d0a

Where

    0d = line break chr(10) i.e. \r
    0a = new line chr(13) i.e \n

I have chosen to ignore this since I can't figure out any other logic/pattern around it.


# ArgumentParser
The properties could be injected from outside, but then again, it will not be more generic by that as of now.

## Optional
A note on the use of Optional.

Instead of:

    FormatEnum formatEnum = null;
    Integer width = null;

, I could have used:

    Optional<FormatEnum> oFormatEnum = Optional.empty();
    Optional<Integer: width = Optional.empty();

, and then e.g.

    FormatEnum formatEnum = oFormatEnum.orElseThrow(() -> new IllegalArgumentException("FormatEnum is null"));

, and let the toEnum return an optional:

    public static Optional<FormatEnum> toEnum(String type) {
        ...
        return Arrays.stream(FormatEnum.values())
            .filter(x -> x.type().equalsIgnoreCase(type))
            .findFirst();
    }

, but then the exception thrown to the caller becomes an interpretation (the root cause is hidden). Then one could argue
that the user does not need detailed info.. and that these details could be logged instead. But then again, I like to
throw the details back to the caller, if mandatory. Also I like to avoid logging, especially in adapters, i.e. persist
or log the exception at the caller. The code just becomes more clean without log statements all over the place.
Secondly, I like to write stacktrace to db that is referenced to a workflowId (if that is the case).

Properties
Logging should be done.

BeanConfig
This class can be seen as the @Bean annotation in Spring i.e. the usage of DI.

# Formatter
Comments about the formatters.


Code like the below (LeftAlignFormatter):

             if (len >= width) {
                if (!alignment.isEmpty()) {
                    addSpacesToAlignment(alignment, width - alignment.length());
                    appendToResult(alignment, result);
                    clear(alignment);
                }

                appendToResult(token, result);

            } else {
           ...

, could be written as

            if (isTokenGreaterThanOrEqualWidth(len, width)) {
                if (isAlignmentNotEmpty(alignment)) {
                    addSpacesAndAppendToResult(alignment, result, width);
                }

                appendToResult(token, result);

            } else {
           ...

The main logic in the loop is the same for left, right and center i.e. the private methods in the loop could take the format type
as parameter and then depending on the type, the text would be left, right or center ie change between e.g. *append* and
*insert*.

One could also inject interface (Strategy) implementations of left, right and center e.g. either an implementation of adding spaces
to the right, for left alignment, or inserting (prepending) spaces for right alignment. The good thing about that solution
is that, there is only one class with one loop, though with several injected resources for left, right and center respectively.

If doing this again, I would have choose the latter solution i.e. injecting primitives (implementing interfaces)

# Enum
My comments on enum.

id (persisting)
AttributeConverter... Spring-boot upgrade. Unpleasant surprises upon upgrade from e.g. 2.x.x to 3.x.x.

# Hibernate
My comment on Hibernate.

Have the extra mapping of the entity to domain model.

Exclusion



Warnings
There are no warnings in the build. It is quite important. It is like a mental overhead to be notified
constantly about warnings or "errors" - that are not errors. False positive are just mental overhead and
to me part of technical debt.


# Spring-boot
## Intro
Spring-boot projects (microservice) quickly take in a lot of dependencies like:

* OpenAPI
* Apache Kafka
* Apache Cassandra
* Mongodb
* Redis
* Hibernate
* JDBC
* HikariCP

, and it can quickly become a problem with raw types and library methods used all over the place. It will, most likely,
be a problem sooner or later, since the project will start to be tight coupled with raw library types and methods i.e.
having dependencies.
If the project is created by 1 developer it can be fine, but usually many developers are working on the same project i.e.
suddenly there is a high demand for extra communication of extra standards, like "remember not to do like this and that".
Not only does it take time to communicate and describe (maybe in a Developer Guide), but also it is like a mental overhead
or mind-shift. I think it is important to remove unnecessary and mind-shifting, since we loose focus on the task at hand.

## Unit test




# Requirements
Install these dependencies

* Java 21
* Maven (3.9.9) 

, and set these environment variables

    JAVA_HOME
    M2_HOME

# Run
To build the application goto to project root and run

    mvn clean install

To run the application goto

    ../modules/core

And run

    java -jar format.jar --help

You will then get more detailed help.

# Test
Goto project root and run

    mvn test

# Debug

Set the classpath to

    com.pub.core

The main class is located in

    com.pub.core.Main

Set the parameters in "Program arguments" (for parameter options, see "Run" above).

You should now be able to debug the application.