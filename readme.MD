# Intro
The below is a description of the choices I made and why for this task - but also thoughts in general.

Upon reading the task description, I took note of these two statements:

* The application must be written in a way that makes it possible to implement remaining algorithms without any considerable changes to existing code.
* It is allowed to use junit dependency for tests.

The above statements are like the "alpha" and the "omega", in my mind. Not practicing these principles lead to not
*Clean Code* and at the end of the day, technical debt.

So with the above in mind - code that can be unit tested, reused and extended - but also with Spring-boot in mind -
I have used the *Port Adapter* pattern for the task.

Yes, it is completely over-kill for the task being, but it illustrates the point.

# Port adapter
Also called the *Hexagon* pattern. I guess the term is borrowed from DDD i.e. Domain Driven Design, and it was coined around 2008-2011.

I was introduced to this pattern by a tech lead person. In the beginning, I didn't like it at all.

Some of my thoughts were:

* Oh well, I know perfectly well how to decouple.
* I know how to use an interface. What have we? Strategy, visitor, delegator etc.
* And yes, I know SOLID, principles, patterns and best practice.
* I know how to do unit test.
* It is waste of time with all these bloated adapters i.e. maven modules. It is confusing.
* I can perfectly well make a nice project structure - without modules.
* .. etc. etc.

The fact is that I use it now. I recommend this pattern in every larger Spring-boot project - with many developers.
Why? I would like to explain the pattern.

It consists of these elements (maven modules):

* Port (interfaces)
* Adapters (raw implementation)
* Domain (model i.e. POJO's and interfaces)
* Core (SpringBoot application startup)
* Config (Beans, properties etc.)
* Use-case (the business logic)

## Note
The pattern is called *Port and Adapter*, but actually the "port part" are the interfaces used which are located in
the domain module. In the following the *Port* is part of the *Domain*.

## Adapters
An *Adapter* is an implementation of some resource using raw types and methods from a particular library.

### Implementation
Implementations could be:

* SQL client doing CRUD operations.
* Apache Kafka client (publishing messages) or listener.
* REST client or endpoint.

The resource uses raw types for that implementation in question.

Example types are:

* DTO's generated by OpenAPI (openapi-generator-maven-plugin).
* Hibernate entities.

The adapter must implement a (port) interface.

### Calling
The adapter can be:

* called by the initiator e.g. like a *client*.
* or make a call-back to the initiator e.g. like a *listener*.

Regardless, the type of call, a port interface must be used.
Parameters used in constructors and methods are domain type (or native types).

### Mapping
Mappers are located in the adapter. They're able to map between domain types and raw adapter types.
Raw adapter types does *not* escape the adapter. It is very important.

### Dependencies
The adapter only has two Maven dependencies:

* the library used for that particular adapter e.g. Apache Kafka.
* the domain model.

Besides the above, the adapter is oblivious to all other modules in the project.

### Important
Important rules:
* adapters do not know anything about the use-case i.e. the business logic. They are decoupled through the port interface.
* adapters do not know about other adapters or use (inject) other adapters.

## Domain
The domain consists of the *Types* and *Ports* used in the project.

### Types
This is basically POJO's without any annotations besides (maybe) Lombok.

### Port
Here the port interfaces reside each implemented by some adapter.

### Dependencies
The domain modules have no dependencies to other modules.

### Important
And again, an important rule for the domain module is:
* the domain module has no dependency to other maven modules.

## Use-case
The use-case is the business logic. From a dependency point of view, it only knows the domain types and ports, not the
concrete adapter implementation. It is literately impossible to instantiate a concrete type of some adapter and use it
in the use case.

### Dependencies
* domain model (and port interfaces)
 
### Important
In other words, these rules are very important for the use-case module:
* only uses domain types (not raw 3rd part library types or methods).
* only uses port interfaces (not a concrete implementation of an adapter).

## Config
The *Config* module configures the dependency management i.e. bean instantiation and injection throughout the project.

### Dependencies
What ever maven dependencies that are needed to instantiate resources.

### Important
It only does Dependency Management i.e. instantiation and configuration. E.g. for Spring-boot also security config.

## Main
The *Main* module is responsible for starting the application e.g. like *main* or *SpringBootApplication*.

## Conclusion
The result of using this pattern:
* decoupled - the use-case and adapters are completely decoupled. It is literately impossible to instantiate a concrete
  adapter implementation, thus it is not possible to have raw 3rd part types and library methods mixed with business logic.
  All in all, there is a good chance for *Clean Code*. 
* unit test (use-case) - because of the decoupling, the use-case unit test becomes very simple and clean, since it only
  focuses on business logic and domain types (includes port interfaces). Mocking and stubbing domain types and interfaces
  are very simple i.e. configuration details for mocking libraries like e.g. H2 are not bloating the use-case unit test. 
  And SpringBootTest is not used in this test.
* unit test (adapter) - this unit test is testing the concrete adapter implementation and which is tight coupled to 3rd part
  library dependencies. And that is fine. And again, test library dependencies can be used in the adapter e.g. H2. But again,
  neither the 3rd part library raw types or methods - nor H2 is mixed with the use-case. In other words, the separation is
  two-fold, both in the production code (abstraction) and thus in the unit test.
* overview - it is easy to overview the project since there is a clean distinction between use-case and adapter implementation.
  Especially in projects with many developers commiting to the same project.
* template - a standard project template can be made with most common modules and adapters e.g. Kafka, Cassandra, Mongodb, SQL etc. etc..
* standard - it (maybe) makes it easier to communicate and keep the project *clean* (what ever that term is defined as).

# Questions

## 0d0a
It is not seen in the output example in the PDF, but this can be seen when looking in a hex editor:

    0d0a

Where

    0d = line break chr(10) i.e. \r
    0a = new line chr(13) i.e \n

I have chosen to ignore this since I can't figure out any other logic/pattern around it.

# ArgumentParser (adapter)

## Optional
Instead of:

    FormatEnum formatEnum = null;
    Integer width = null;

I could have used:

    Optional<FormatEnum> oFormatEnum = Optional.empty();
    Optional<Integer: width = Optional.empty();

And then e.g.

    FormatEnum formatEnum = oFormatEnum.orElseThrow(() -> new IllegalArgumentException("FormatEnum is null"));

And let the toEnum return an optional:

    public static Optional<FormatEnum> toEnum(String type) {
        ...
        return Arrays.stream(FormatEnum.values())
            .filter(x -> x.type().equalsIgnoreCase(type))
            .findFirst();
    }

I decided not to use Optional, since I see it as an error if the enum is not found.
Also, if returning an optional, the exception thrown, is an interpretation - not the actual cause.

# Console (adapter)
Both the *ConsoleInputReader* and the *ConsoleOutputWriter* are tightly coupled i.e. making the Scanner resource and using println respectively.

# Formatter adapter
In the beginning I had 2 classes for left and right formatting, but the loop is basically doing the same thing regardless
the type of formatting. Thus, I decided to just have one class i.e. one loop in all - and then injecting resources depending
on the type of format.

## Note on describing operators
It can sometimes be easier to read code like that. As an example, the LeftAlignFormatter was like the below:

     if (len >= width) {
        if (!alignment.isEmpty()) {
            addSpacesToAlignment(alignment, width - alignment.length());
            appendToResult(alignment, result);
            clear(alignment);
        }

        appendToResult(token, result);

    } else {
   ...

, which could be written as:

    if (isTokenGreaterThanOrEqualWidth(len, width)) {
        if (isAlignmentNotEmpty(alignment)) {
            addSpacesAndAppendToResult(alignment, result, width);
        }

        appendToResult(token, result);

    } else {
   ...

Again, it depends on what people like as standard.

# BeanConfig
This class can be seen as Spring-boot config class setting up @Beans for dependency management.

## Properties
Logging should be done instead of just using *System.out.println* for the exception message.

# Enum
I did not have any use for an *id* i.e. I removed it not to have a warning. But when I do need it, I write the type
as below:

    LEFT_ALIGNED(0, "left", "Left aligned"),
    RIGHT_ALIGNED(1, "right", "Left aligned"),
    CENTERED(2, "centered", "Centered");

    final private int id;
    final private String type;
    final private String description;

    FormatEnum(int id, String type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
    }

    public int id() {
        return id;
    }

    public String type() {
        return type;
    }

    public String description() {
        return description;
    }

    public static FormatEnum toEnum(int id) {
        return Arrays.stream(FormatEnum.values())
            .filter(x -> x.id() == id)
            .findFirst().orElseThrow(() ->
                new IllegalArgumentException(String.format("Unknown format type. id = %d", id)));
    }

    public static FormatEnum toEnum(String type) {
        Objects.requireNonNull(type, "Format type can not be null");
        return Arrays.stream(FormatEnum.values())
            .filter(x -> x.type().equalsIgnoreCase(type))
            .findFirst().orElseThrow(() ->
                new IllegalArgumentException(String.format("Unknown format type. type = %s", type)));
    }

Often the enum type is written to db and instead of a char type I like better to use integer in the db (for more on
Hibernate, see below).

# Hibernate
My comment on Hibernate.
AttributeConverter... Spring-boot upgrade. Unpleasant surprises upon upgrade from e.g. 2.x.x to 3.x.x.

Have the extra mapping of the entity to domain model.

Exclusion

# Warnings
I think it is important to remove compile and build warnings. I see it as technical debt. It is just waste of time
constantly confirming that some warning should be ignored - which actually is wrong.



# Spring-boot
## Intro
Spring-boot projects (microservice) quickly take in a lot of dependencies like:

* OpenAPI
* Apache Kafka
* Apache Cassandra
* Mongodb
* Redis
* Hibernate
* JDBC
* HikariCP

And it can quickly become a problem with raw types and library methods used all over the place. It will, most likely,
be a problem sooner or later, since the project will start to be tight coupled with raw library types and methods i.e.
having dependencies.
If the project is created by 1 developer it can be fine, but usually many developers are working on the same project i.e.
suddenly there is a high demand for extra communication of extra standards, like "remember not to do like this and that".
Not only does it take time to communicate and describe (maybe in a Developer Guide), but also it is like a mental overhead
or mind-shift. I think it is important to remove unnecessary and mind-shifting, since we loose focus on the task at hand.

## Unit test




# Requirements
Install these dependencies

* Java 21
* Maven (3.9.9) 

And set these environment variables

    JAVA_HOME
    M2_HOME

# Run
To build the application goto to project root and run

    mvn clean install

To run the application goto

    ../modules/core

And run

    java -jar format.jar --help

You will then get more detailed help.

# Test
Goto project root and run

    mvn test

# Debug

Set the classpath to

    com.pub.core

The main class is located in

    com.pub.format.modules.core.Main

Set the parameters in "Program arguments" (for parameter options, see "Run" above).

You should now be able to debug the application.
